#!/bin/bash

# Amount of time that the command may run for before being killed
timeout="10"

saveIFS="$IFS"
IFS='=&'
query=($QUERY_STRING)
IFS=$saveIFS

input=
print_exit=0
args=()
for ((i=0; i<${#query[@]}; i+=2)); do
  query_name="$(decode_url "${query[i]}")"
  query_value="$(decode_url "${query[i+1]}")"
  if [ "${query_name}" = "arg" ]; then
    args+=("${query_value}")
  elif [ "${query_name}" = "exit" ]; then
    print_exit=1
  elif [ "${query_name}" = "input" ]; then
    input="${query_value}"
  fi
done

set_response_header "Content-Type" "text/plain; charset=utf8"

command="$(decode_url "$(sed 's|^/*||' <<< "${REQUEST_PATH}")")"
set_response_header "X-Cmd" "${command}"
#if [ "${#args[@]}" -gt 0 ]; then
#  set_response_header "X-Args" "$(printf "'%s' " "${args[@]}")"
#fi

if [ ! -z "${input}" ]; then
  # Close HTTP request body stdin,
  # and redirect stdin to be the curl response body
  exec <&-
  exec < <(curl "${input}" --silent --show-error --no-buffer 2>&1)
fi

timeout -t "${timeout}" "${command}" "${args[@]}" 2>&1
exit_code=$?
recv "Exit code: ${exit_code}"

if [ "${exit_code}" = 143 ]; then
  echo "Command timed out (${timeout}s): ${command} ${args[*]}"
fi

if [ "${print_exit}" -eq 1 ]; then
  echo "${exit_code}"
fi
